[
  {
    "id": 1,
    "question": "What is Object vs Class in OOP?",
    "answer": "An object is a runtime instance with state and behavior; a class is the blueprint that defines that state (fields) and behavior (methods). Many objects can be created from one class.\n\nPython:\nclass Car: pass\nc = Car()  # c is an object (instance) of class Car\n\nJava:\nclass Car {}\nCar c = new Car(); // object from class Car\n\nC++:\nstruct Car {};\nCar c; // c is an object (instance)"
  },
  {
    "id": 2,
    "question": "When and why would you use Object vs Class?",
    "answer": "Use object vs class to improve design quality: An object is a runtime instance with state and behavior; a class is the blueprint that defines that state (fields) and behavior (methods). Many objects can be created from one class.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 3,
    "question": "What are common pitfalls or misconceptions about Object vs Class?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: An object is a runtime instance with state and behavior; a class is the blueprint that defines that state (fields) and behavior (methods). Many objects can be created from one class."
  },
  {
    "id": 4,
    "question": "What is Encapsulation in OOP?",
    "answer": "Encapsulation bundles data and the methods that operate on that data, and restricts direct access to some components using access modifiers or conventions. It protects invariants and supports information hiding.\n\nPython:\nclass Bank:\n    def __init__(self): self._balance = 0  # '_' signals internal\n    def deposit(self, amt):\n        if amt <= 0: raise ValueError('positive')\n        self._balance += amt\n    @property\n    def balance(self): return self._balance\n\nJava:\nclass Bank { private int balance=0; public void deposit(int a){ if(a<=0) throw new IllegalArgumentException(); balance+=a;} public int getBalance(){return balance;} }\n\nC++:\nclass Bank { int balance{0}; public: void deposit(int a){ if(a<=0) throw std::invalid_argument(\"+\"); balance+=a;} int getBalance() const { return balance; } };"
  },
  {
    "id": 5,
    "question": "When and why would you use Encapsulation?",
    "answer": "Use encapsulation to improve design quality: Encapsulation bundles data and the methods that operate on that data, and restricts direct access to some components using access modifiers or conventions. It protects invariants and supports information hiding.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 6,
    "question": "What are common pitfalls or misconceptions about Encapsulation?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Encapsulation bundles data and the methods that operate on that data, and restricts direct access to some components using access modifiers or conventions. It protects invariants and supports information hiding."
  },
  {
    "id": 7,
    "question": "What is Abstraction in OOP?",
    "answer": "Abstraction exposes essential behavior while hiding unnecessary details. It’s achieved via abstract classes, interfaces, and well‑designed APIs.\n\nPython:\nfrom abc import ABC, abstractmethod\nclass Notifier(ABC):\n    @abstractmethod\n    def send(self, msg): ...\n\nJava:\ninterface Notifier { void send(String msg); }\n\nC++:\nstruct Notifier { virtual void send(const std::string&)=0; virtual ~Notifier()=default; };"
  },
  {
    "id": 8,
    "question": "When and why would you use Abstraction?",
    "answer": "Use abstraction to improve design quality: Abstraction exposes essential behavior while hiding unnecessary details. It’s achieved via abstract classes, interfaces, and well‑designed APIs.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 9,
    "question": "What are common pitfalls or misconceptions about Abstraction?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Abstraction exposes essential behavior while hiding unnecessary details. It’s achieved via abstract classes, interfaces, and well‑designed APIs."
  },
  {
    "id": 10,
    "question": "What is Inheritance in OOP?",
    "answer": "Inheritance lets a class acquire behavior and state from a parent (base) class. Prefer composition when inheritance does not model an 'is‑a' relationship or would increase coupling.\n\nPython:\nclass Animal: pass\nclass Dog(Animal): pass\n\nJava:\nclass Animal {}\nclass Dog extends Animal {}\n\nC++:\nstruct Animal{}; struct Dog: Animal {};"
  },
  {
    "id": 11,
    "question": "When and why would you use Inheritance?",
    "answer": "Use inheritance to improve design quality: Inheritance lets a class acquire behavior and state from a parent (base) class. Prefer composition when inheritance does not model an 'is‑a' relationship or would increase coupling.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 12,
    "question": "What are common pitfalls or misconceptions about Inheritance?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Inheritance lets a class acquire behavior and state from a parent (base) class. Prefer composition when inheritance does not model an 'is‑a' relationship or would increase coupling."
  },
  {
    "id": 13,
    "question": "What is Polymorphism in OOP?",
    "answer": "Polymorphism lets code use objects of different types through a common interface. Subtype (runtime) polymorphism dispatches based on the object's dynamic type; parametric polymorphism is via generics/templates; ad‑hoc via overloading.\n\nPython:\ndef area(shape): return shape.area()  # duck typing\n\nJava:\nShape s = new Circle(); s.area(); // dynamic dispatch\n\nC++:\nstruct Shape{ virtual double area() const=0; virtual ~Shape()=default; }; struct Circle: Shape{ double r; double area() const override {return 3.14*r*r;} };"
  },
  {
    "id": 14,
    "question": "When and why would you use Polymorphism?",
    "answer": "Use polymorphism to improve design quality: Polymorphism lets code use objects of different types through a common interface. Subtype (runtime) polymorphism dispatches based on the object's dynamic type; parametric polymorphism is via generics/templates; ad‑hoc via overloading.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 15,
    "question": "What are common pitfalls or misconceptions about Polymorphism?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Polymorphism lets code use objects of different types through a common interface. Subtype (runtime) polymorphism dispatches based on the object's dynamic type; parametric polymorphism is via generics/templates; ad‑hoc via overloading."
  },
  {
    "id": 16,
    "question": "What is Composition over Inheritance in OOP?",
    "answer": "Favor composition to assemble behaviors at runtime instead of deep inheritance hierarchies. Composition reduces coupling and avoids fragile base class problems.\n\nPython:\nclass Car:\n    def __init__(self, engine): self.engine=engine\n    def drive(self): self.engine.run()\n\nJava:\nclass Car { private Engine engine; Car(Engine e){this.engine=e;} void drive(){engine.run();} }\n\nC++:\nstruct Car{ Engine engine; void drive(){ engine.run(); } };"
  },
  {
    "id": 17,
    "question": "When and why would you use Composition over Inheritance?",
    "answer": "Use composition over inheritance to improve design quality: Favor composition to assemble behaviors at runtime instead of deep inheritance hierarchies. Composition reduces coupling and avoids fragile base class problems.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 18,
    "question": "What are common pitfalls or misconceptions about Composition over Inheritance?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Favor composition to assemble behaviors at runtime instead of deep inheritance hierarchies. Composition reduces coupling and avoids fragile base class problems."
  },
  {
    "id": 19,
    "question": "What is Interfaces vs Abstract Classes in OOP?",
    "answer": "Interfaces specify contracts without state; abstract classes can hold state and default behavior. Use an interface for capability, an abstract base when sharing partial implementation.\n\nPython:\nfrom abc import ABC, abstractmethod\nclass Repo(ABC): @abstractmethod\n    def get(self,id): ...  # ABC is Python's 'interface'\n\nJava:\ninterface Repo { Item get(int id); }\nabstract class BaseRepo implements Repo { protected Logger log; }\n\nC++:\nstruct Repo{ virtual Item get(int)=0; virtual ~Repo()=default; }; // pure abstract base"
  },
  {
    "id": 20,
    "question": "When and why would you use Interfaces vs Abstract Classes?",
    "answer": "Use interfaces vs abstract classes to improve design quality: Interfaces specify contracts without state; abstract classes can hold state and default behavior. Use an interface for capability, an abstract base when sharing partial implementation.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 21,
    "question": "What are common pitfalls or misconceptions about Interfaces vs Abstract Classes?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Interfaces specify contracts without state; abstract classes can hold state and default behavior. Use an interface for capability, an abstract base when sharing partial implementation."
  },
  {
    "id": 22,
    "question": "What is Method Overloading vs Overriding in OOP?",
    "answer": "Overloading: same name, different parameters in the same class (resolved at compile time). Overriding: subclass provides its own implementation of a base method with the same signature (resolved at runtime via dynamic dispatch).\n\nPython:\nPython has no traditional overloading; use *args or singledispatch. Overriding happens by redefining methods in subclasses.\n\nJava:\n@Override ensures overriding; overloading uses different parameter lists.\n\nC++:\nUse 'override' for overriding; overloading requires different signatures; beware hiding with using-declarations."
  },
  {
    "id": 23,
    "question": "When and why would you use Method Overloading vs Overriding?",
    "answer": "Use method overloading vs overriding to improve design quality: Overloading: same name, different parameters in the same class (resolved at compile time). Overriding: subclass provides its own implementation of a base method with the same signature (resolved at runtime via dynamic dispatch).\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 24,
    "question": "What are common pitfalls or misconceptions about Method Overloading vs Overriding?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Overloading: same name, different parameters in the same class (resolved at compile time). Overriding: subclass provides its own implementation of a base method with the same signature (resolved at runtime via dynamic dispatch)."
  },
  {
    "id": 25,
    "question": "What is Access Modifiers in OOP?",
    "answer": "Modifiers control visibility. Public is everywhere; protected is subclass (and package in Java); private is within the class. Python uses naming conventions (_protected, __mangled).\n\nPython:\nclass A: def __init__(self): self.public=1; self._internal=2; self.__mangled=3\n\nJava:\npublic / protected / (package-private) / private\n\nC++:\npublic / protected / private sections in class"
  },
  {
    "id": 26,
    "question": "When and why would you use Access Modifiers?",
    "answer": "Use access modifiers to improve design quality: Modifiers control visibility. Public is everywhere; protected is subclass (and package in Java); private is within the class. Python uses naming conventions (_protected, __mangled).\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 27,
    "question": "What are common pitfalls or misconceptions about Access Modifiers?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Modifiers control visibility. Public is everywhere; protected is subclass (and package in Java); private is within the class. Python uses naming conventions (_protected, __mangled)."
  },
  {
    "id": 28,
    "question": "What is Constructors & Destructors in OOP?",
    "answer": "Constructors initialize new objects. Destructors (C++) release resources deterministically (RAII). In Java/Python, use try-with-resources / context managers for timely cleanup.\n\nPython:\nclass File: def __enter__(self):...; def __exit__(self,*exc):...\n\nJava:\ntry (var in = Files.newInputStream(p)) { ... }\n\nC++:\nstruct F{ F(){/*open*/} ~F(){/*close*/} }; // RAII"
  },
  {
    "id": 29,
    "question": "When and why would you use Constructors & Destructors?",
    "answer": "Use constructors & destructors to improve design quality: Constructors initialize new objects. Destructors (C++) release resources deterministically (RAII). In Java/Python, use try-with-resources / context managers for timely cleanup.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 30,
    "question": "What are common pitfalls or misconceptions about Constructors & Destructors?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Constructors initialize new objects. Destructors (C++) release resources deterministically (RAII). In Java/Python, use try-with-resources / context managers for timely cleanup."
  },
  {
    "id": 31,
    "question": "What is Deep vs Shallow Copy in OOP?",
    "answer": "Shallow copy duplicates the top-level object and shares nested references; deep copy duplicates the entire object graph. Choose based on ownership semantics.\n\nPython:\nimport copy; shallow = copy.copy(obj); deep = copy.deepcopy(obj)\n\nJava:\nImplement Cloneable carefully; prefer copy constructors/immutability.\n\nC++:\nDefine copy ctor/assign for deep copy; use smart pointers to encode ownership."
  },
  {
    "id": 32,
    "question": "When and why would you use Deep vs Shallow Copy?",
    "answer": "Use deep vs shallow copy to improve design quality: Shallow copy duplicates the top-level object and shares nested references; deep copy duplicates the entire object graph. Choose based on ownership semantics.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 33,
    "question": "What are common pitfalls or misconceptions about Deep vs Shallow Copy?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Shallow copy duplicates the top-level object and shares nested references; deep copy duplicates the entire object graph. Choose based on ownership semantics."
  },
  {
    "id": 34,
    "question": "What is Equality: structural vs referential in OOP?",
    "answer": "Referential equality checks identity (same object). Structural equality compares state. Ensure equals/hashCode consistency in Java and __eq__/__hash__ in Python.\n\nPython:\nclass V: def __eq__(self,o): return isinstance(o,V) and self.x==o.x\n\nJava:\nOverride equals() and hashCode() consistently.\n\nC++:\nDefine operator== and optionally operator<=>."
  },
  {
    "id": 35,
    "question": "When and why would you use Equality: structural vs referential?",
    "answer": "Use equality: structural vs referential to improve design quality: Referential equality checks identity (same object). Structural equality compares state. Ensure equals/hashCode consistency in Java and __eq__/__hash__ in Python.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 36,
    "question": "What are common pitfalls or misconceptions about Equality: structural vs referential?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Referential equality checks identity (same object). Structural equality compares state. Ensure equals/hashCode consistency in Java and __eq__/__hash__ in Python."
  },
  {
    "id": 37,
    "question": "What is Static vs Instance members in OOP?",
    "answer": "Static members belong to the class, not instances; instance members are per-object. Static methods cannot access instance state unless an instance is provided.\n\nPython:\nclass A: @staticmethod\n    def util(): ...\n    @classmethod\n    def from_x(cls,x): return cls()\n\nJava:\nstatic int count; static void util(){}\n\nC++:\nstruct A{ static int count; }; int A::count=0;"
  },
  {
    "id": 38,
    "question": "When and why would you use Static vs Instance members?",
    "answer": "Use static vs instance members to improve design quality: Static members belong to the class, not instances; instance members are per-object. Static methods cannot access instance state unless an instance is provided.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 39,
    "question": "What are common pitfalls or misconceptions about Static vs Instance members?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Static members belong to the class, not instances; instance members are per-object. Static methods cannot access instance state unless an instance is provided."
  },
  {
    "id": 40,
    "question": "What is UML Basics in OOP?",
    "answer": "Class diagrams show classes, members, and relationships (association, aggregation, composition, inheritance, dependency). Solid diamonds mean composition; open diamonds aggregation.\n\nPython:\n—\n\nJava:\n—\n\nC++:\n—"
  },
  {
    "id": 41,
    "question": "When and why would you use UML Basics?",
    "answer": "Use uml basics to improve design quality: Class diagrams show classes, members, and relationships (association, aggregation, composition, inheritance, dependency). Solid diamonds mean composition; open diamonds aggregation.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 42,
    "question": "What are common pitfalls or misconceptions about UML Basics?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Class diagrams show classes, members, and relationships (association, aggregation, composition, inheritance, dependency). Solid diamonds mean composition; open diamonds aggregation."
  },
  {
    "id": 43,
    "question": "What is SOLID: SRP in OOP?",
    "answer": "Single Responsibility Principle: a class should have one reason to change—encapsulating a single responsibility or axis of change.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 44,
    "question": "When and why would you use SOLID: SRP?",
    "answer": "Use solid: srp to improve design quality: Single Responsibility Principle: a class should have one reason to change—encapsulating a single responsibility or axis of change.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 45,
    "question": "What are common pitfalls or misconceptions about SOLID: SRP?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Single Responsibility Principle: a class should have one reason to change—encapsulating a single responsibility or axis of change."
  },
  {
    "id": 46,
    "question": "What is SOLID: OCP in OOP?",
    "answer": "Open/Closed Principle: software entities should be open for extension but closed for modification—achieved via interfaces, strategies, and composition.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 47,
    "question": "When and why would you use SOLID: OCP?",
    "answer": "Use solid: ocp to improve design quality: Open/Closed Principle: software entities should be open for extension but closed for modification—achieved via interfaces, strategies, and composition.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 48,
    "question": "What are common pitfalls or misconceptions about SOLID: OCP?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Open/Closed Principle: software entities should be open for extension but closed for modification—achieved via interfaces, strategies, and composition."
  },
  {
    "id": 49,
    "question": "What is SOLID: LSP in OOP?",
    "answer": "Liskov Substitution Principle: objects of a superclass should be replaceable with objects of a subclass without breaking correctness. Strengthen postconditions? OK. Weaken preconditions? OK. Don't violate invariants.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 50,
    "question": "When and why would you use SOLID: LSP?",
    "answer": "Use solid: lsp to improve design quality: Liskov Substitution Principle: objects of a superclass should be replaceable with objects of a subclass without breaking correctness. Strengthen postconditions? OK. Weaken preconditions? OK. Don't violate invariants.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 51,
    "question": "What are common pitfalls or misconceptions about SOLID: LSP?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Liskov Substitution Principle: objects of a superclass should be replaceable with objects of a subclass without breaking correctness. Strengthen postconditions? OK. Weaken preconditions? OK. Don't violate invariants."
  },
  {
    "id": 52,
    "question": "What is SOLID: ISP in OOP?",
    "answer": "Interface Segregation Principle: prefer many small, client‑specific interfaces over one large general‑purpose interface.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 53,
    "question": "When and why would you use SOLID: ISP?",
    "answer": "Use solid: isp to improve design quality: Interface Segregation Principle: prefer many small, client‑specific interfaces over one large general‑purpose interface.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 54,
    "question": "What are common pitfalls or misconceptions about SOLID: ISP?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Interface Segregation Principle: prefer many small, client‑specific interfaces over one large general‑purpose interface."
  },
  {
    "id": 55,
    "question": "What is SOLID: DIP in OOP?",
    "answer": "Dependency Inversion Principle: high‑level modules depend on abstractions, not concretes. Inject dependencies via constructors/factories.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 56,
    "question": "When and why would you use SOLID: DIP?",
    "answer": "Use solid: dip to improve design quality: Dependency Inversion Principle: high‑level modules depend on abstractions, not concretes. Inject dependencies via constructors/factories.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 57,
    "question": "What are common pitfalls or misconceptions about SOLID: DIP?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Dependency Inversion Principle: high‑level modules depend on abstractions, not concretes. Inject dependencies via constructors/factories."
  },
  {
    "id": 58,
    "question": "What is Design by Contract in OOP?",
    "answer": "Specify preconditions, postconditions, and invariants. Enforce with validations, assertions, and tests; document in code and API contracts.\n\nPython:\nassert n>0, 'n must be positive'\n\nJava:\nObjects.requireNonNull(x)\n\nC++:\nassert(n>0);"
  },
  {
    "id": 59,
    "question": "When and why would you use Design by Contract?",
    "answer": "Use design by contract to improve design quality: Specify preconditions, postconditions, and invariants. Enforce with validations, assertions, and tests; document in code and API contracts.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 60,
    "question": "What are common pitfalls or misconceptions about Design by Contract?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Specify preconditions, postconditions, and invariants. Enforce with validations, assertions, and tests; document in code and API contracts."
  },
  {
    "id": 61,
    "question": "What is Immutability in OOP?",
    "answer": "Immutable objects can't change after construction. They are inherently thread‑safe, cacheable, and simpler to reason about. Build via constructors/builders and defensive copies.\n\nPython:\nfrom dataclasses import dataclass\n@dataclass(frozen=True)\nclass Money: amount:int; currency:str\n\nJava:\nrecord Money(int amount, String currency) {}\n\nC++:\nPrefer const, avoid exposing mutators; consider value types."
  },
  {
    "id": 62,
    "question": "When and why would you use Immutability?",
    "answer": "Use immutability to improve design quality: Immutable objects can't change after construction. They are inherently thread‑safe, cacheable, and simpler to reason about. Build via constructors/builders and defensive copies.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 63,
    "question": "What are common pitfalls or misconceptions about Immutability?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Immutable objects can't change after construction. They are inherently thread‑safe, cacheable, and simpler to reason about. Build via constructors/builders and defensive copies."
  },
  {
    "id": 64,
    "question": "What is Multiple Inheritance & Diamond in OOP?",
    "answer": "Multiple inheritance allows a class to inherit from multiple bases. Diamonds can cause ambiguity; C++ uses virtual inheritance; Java disallows MI of classes, allows multiple interfaces; Python uses MRO (C3 linearization).\n\nPython:\nclass D(B1,B2): ...  # resolved by MRO\n\nJava:\nclass D implements I1, I2 {} // methods must be unambiguous\n\nC++:\nstruct A{}; struct B1: virtual A{}; struct B2: virtual A{}; struct D: B1,B2{};"
  },
  {
    "id": 65,
    "question": "When and why would you use Multiple Inheritance & Diamond?",
    "answer": "Use multiple inheritance & diamond to improve design quality: Multiple inheritance allows a class to inherit from multiple bases. Diamonds can cause ambiguity; C++ uses virtual inheritance; Java disallows MI of classes, allows multiple interfaces; Python uses MRO (C3 linearization).\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 66,
    "question": "What are common pitfalls or misconceptions about Multiple Inheritance & Diamond?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Multiple inheritance allows a class to inherit from multiple bases. Diamonds can cause ambiguity; C++ uses virtual inheritance; Java disallows MI of classes, allows multiple interfaces; Python uses MRO (C3 linearization)."
  },
  {
    "id": 67,
    "question": "What is MRO & super() in Python in OOP?",
    "answer": "Python’s Method Resolution Order (C3) defines how attributes are looked up in MI. super() follows MRO, enabling cooperative multiple inheritance.\n\nPython:\nclass A: pass\nclass B(A): pass\nclass C(A): pass\nclass D(B,C): pass\nD.__mro__\n\nJava:\n\n\nC++:"
  },
  {
    "id": 68,
    "question": "When and why would you use MRO & super() in Python?",
    "answer": "Use mro & super() in python to improve design quality: Python’s Method Resolution Order (C3) defines how attributes are looked up in MI. super() follows MRO, enabling cooperative multiple inheritance.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 69,
    "question": "What are common pitfalls or misconceptions about MRO & super() in Python?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Python’s Method Resolution Order (C3) defines how attributes are looked up in MI. super() follows MRO, enabling cooperative multiple inheritance."
  },
  {
    "id": 70,
    "question": "What is Virtual functions & vtables in OOP?",
    "answer": "In C++, virtual functions enable runtime polymorphism via vtables. A call through a base pointer invokes the overridden method at runtime. Mark overrides with 'override' and ensure a virtual destructor for bases.\n\nPython:\n\n\nJava:\n\n\nC++:\nstruct Base{ virtual ~Base()=default; virtual void f(); }; struct Der: Base{ void f() override; };"
  },
  {
    "id": 71,
    "question": "When and why would you use Virtual functions & vtables?",
    "answer": "Use virtual functions & vtables to improve design quality: In C++, virtual functions enable runtime polymorphism via vtables. A call through a base pointer invokes the overridden method at runtime. Mark overrides with 'override' and ensure a virtual destructor for bases.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 72,
    "question": "What are common pitfalls or misconceptions about Virtual functions & vtables?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: In C++, virtual functions enable runtime polymorphism via vtables. A call through a base pointer invokes the overridden method at runtime. Mark overrides with 'override' and ensure a virtual destructor for bases."
  },
  {
    "id": 73,
    "question": "What is Rule of 3/5/0 (C++) in OOP?",
    "answer": "If a class manages resources, define (at least) destructor, copy ctor, copy assignment (Rule of 3). With C++11+, also move ctor/assignment (Rule of 5). If no resources, rely on defaults (Rule of 0).\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 74,
    "question": "When and why would you use Rule of 3/5/0 (C++)?",
    "answer": "Use rule of 3/5/0 (c++) to improve design quality: If a class manages resources, define (at least) destructor, copy ctor, copy assignment (Rule of 3). With C++11+, also move ctor/assignment (Rule of 5). If no resources, rely on defaults (Rule of 0).\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 75,
    "question": "What are common pitfalls or misconceptions about Rule of 3/5/0 (C++)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: If a class manages resources, define (at least) destructor, copy ctor, copy assignment (Rule of 3). With C++11+, also move ctor/assignment (Rule of 5). If no resources, rely on defaults (Rule of 0)."
  },
  {
    "id": 76,
    "question": "What is RAII (C++) in OOP?",
    "answer": "Resource Acquisition Is Initialization binds resource lifetime to object lifetime. Acquire in constructor, release in destructor; use unique_ptr/shared_ptr and std containers.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 77,
    "question": "When and why would you use RAII (C++)?",
    "answer": "Use raii (c++) to improve design quality: Resource Acquisition Is Initialization binds resource lifetime to object lifetime. Acquire in constructor, release in destructor; use unique_ptr/shared_ptr and std containers.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 78,
    "question": "What are common pitfalls or misconceptions about RAII (C++)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Resource Acquisition Is Initialization binds resource lifetime to object lifetime. Acquire in constructor, release in destructor; use unique_ptr/shared_ptr and std containers."
  },
  {
    "id": 79,
    "question": "What is Smart Pointers (C++) in OOP?",
    "answer": "unique_ptr expresses exclusive ownership; shared_ptr shared ownership; weak_ptr breaks cycles. Prefer make_unique/make_shared.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 80,
    "question": "When and why would you use Smart Pointers (C++)?",
    "answer": "Use smart pointers (c++) to improve design quality: unique_ptr expresses exclusive ownership; shared_ptr shared ownership; weak_ptr breaks cycles. Prefer make_unique/make_shared.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 81,
    "question": "What are common pitfalls or misconceptions about Smart Pointers (C++)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: unique_ptr expresses exclusive ownership; shared_ptr shared ownership; weak_ptr breaks cycles. Prefer make_unique/make_shared."
  },
  {
    "id": 82,
    "question": "What is Generics/Templates/Covariance in OOP?",
    "answer": "Generics (Java), templates (C++) and duck typing/generics (Python) enable parametric polymorphism. Arrays are covariant in Java (unsafe); generics are invariant (use ? extends/? super). C++ templates are compile‑time and T is unconstrained unless concepts used.\n\nPython:\nfrom typing import Protocol\nclass Notifier(Protocol):\n    def send(self, msg:str) -> None: ...\n\nJava:\nList<? extends Number> r; List<? super Integer> w;\n\nC++:\ntemplate<class T> void sort(std::vector<T>& v);"
  },
  {
    "id": 83,
    "question": "When and why would you use Generics/Templates/Covariance?",
    "answer": "Use generics/templates/covariance to improve design quality: Generics (Java), templates (C++) and duck typing/generics (Python) enable parametric polymorphism. Arrays are covariant in Java (unsafe); generics are invariant (use ? extends/? super). C++ templates are compile‑time and T is unconstrained unless concepts used.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 84,
    "question": "What are common pitfalls or misconceptions about Generics/Templates/Covariance?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Generics (Java), templates (C++) and duck typing/generics (Python) enable parametric polymorphism. Arrays are covariant in Java (unsafe); generics are invariant (use ? extends/? super). C++ templates are compile‑time and T is unconstrained unless concepts used."
  },
  {
    "id": 85,
    "question": "What is Casting & RTTI in OOP?",
    "answer": "Downcasting narrows to a subtype; use safely (instanceof / dynamic_cast). Avoid unnecessary casting by designing with interfaces. RTTI queries an object's dynamic type at runtime.\n\nPython:\nisinstance(x, Foo)\n\nJava:\nif (obj instanceof Foo f) { f.bar(); }\n\nC++:\nif (auto p = dynamic_cast<Foo*>(base)) { p->bar(); }"
  },
  {
    "id": 86,
    "question": "When and why would you use Casting & RTTI?",
    "answer": "Use casting & rtti to improve design quality: Downcasting narrows to a subtype; use safely (instanceof / dynamic_cast). Avoid unnecessary casting by designing with interfaces. RTTI queries an object's dynamic type at runtime.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 87,
    "question": "What are common pitfalls or misconceptions about Casting & RTTI?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Downcasting narrows to a subtype; use safely (instanceof / dynamic_cast). Avoid unnecessary casting by designing with interfaces. RTTI queries an object's dynamic type at runtime."
  },
  {
    "id": 88,
    "question": "What is Operator Overloading (C++) in OOP?",
    "answer": "Overload operators to match domain semantics while preserving expectations (e.g., + should be associative/side‑effect free). Prefer non‑member friend for symmetric operators.\n\nPython:\n\n\nJava:\n\n\nC++:\nstruct Vec{ double x,y; };\ninline Vec operator+(Vec a, Vec b){ return {a.x+b.x,a.y+b.y}; }"
  },
  {
    "id": 89,
    "question": "When and why would you use Operator Overloading (C++)?",
    "answer": "Use operator overloading (c++) to improve design quality: Overload operators to match domain semantics while preserving expectations (e.g., + should be associative/side‑effect free). Prefer non‑member friend for symmetric operators.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 90,
    "question": "What are common pitfalls or misconceptions about Operator Overloading (C++)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Overload operators to match domain semantics while preserving expectations (e.g., + should be associative/side‑effect free). Prefer non‑member friend for symmetric operators."
  },
  {
    "id": 91,
    "question": "What is Design Patterns: Strategy in OOP?",
    "answer": "Encapsulate interchangeable algorithms behind a common interface; choose at runtime.\n\nPython:\nclass Strategy: def calc(self,x): ...\n\nJava:\ninterface Strategy { int calc(int x); }\n\nC++:\nstruct Strategy{ virtual int calc(int)=0; virtual ~Strategy()=default; };"
  },
  {
    "id": 92,
    "question": "When and why would you use Design Patterns: Strategy?",
    "answer": "Use design patterns: strategy to improve design quality: Encapsulate interchangeable algorithms behind a common interface; choose at runtime.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 93,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Strategy?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Encapsulate interchangeable algorithms behind a common interface; choose at runtime."
  },
  {
    "id": 94,
    "question": "What is Design Patterns: Factory in OOP?",
    "answer": "Centralize object creation; abstract callers from concrete classes; return interface types.\n\nPython:\ndef make_repo(env): return SqlRepo() if env=='prod' else MemoryRepo()\n\nJava:\nclass RepoFactory{ static Repo make(Env e){...} }\n\nC++:\nstd::unique_ptr<Repo> make_repo(Env e);"
  },
  {
    "id": 95,
    "question": "When and why would you use Design Patterns: Factory?",
    "answer": "Use design patterns: factory to improve design quality: Centralize object creation; abstract callers from concrete classes; return interface types.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 96,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Factory?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Centralize object creation; abstract callers from concrete classes; return interface types."
  },
  {
    "id": 97,
    "question": "What is Design Patterns: Singleton (with caveats) in OOP?",
    "answer": "Ensures a single instance. Often overused; prefer DI. If used, make it lazy, thread‑safe, and testable.\n\nPython:\nclass Singleton: _inst=None\n    def __new__(cls,*a,**k):\n        if not cls._inst: cls._inst=super().__new__(cls)\n        return cls._inst\n\nJava:\nenum Singleton { INSTANCE }\n\nC++:\nT& instance(){ static T inst; return inst; }"
  },
  {
    "id": 98,
    "question": "When and why would you use Design Patterns: Singleton (with caveats)?",
    "answer": "Use design patterns: singleton (with caveats) to improve design quality: Ensures a single instance. Often overused; prefer DI. If used, make it lazy, thread‑safe, and testable.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 99,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Singleton (with caveats)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Ensures a single instance. Often overused; prefer DI. If used, make it lazy, thread‑safe, and testable."
  },
  {
    "id": 100,
    "question": "What is Design Patterns: Adapter/Decorator/Proxy in OOP?",
    "answer": "Adapter converts one interface to another; Decorator adds behavior without subclassing; Proxy controls access (lazy, remote, protection).\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 101,
    "question": "When and why would you use Design Patterns: Adapter/Decorator/Proxy?",
    "answer": "Use design patterns: adapter/decorator/proxy to improve design quality: Adapter converts one interface to another; Decorator adds behavior without subclassing; Proxy controls access (lazy, remote, protection).\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 102,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Adapter/Decorator/Proxy?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Adapter converts one interface to another; Decorator adds behavior without subclassing; Proxy controls access (lazy, remote, protection)."
  },
  {
    "id": 103,
    "question": "What is Design Patterns: Composite in OOP?",
    "answer": "Treat part‑whole hierarchies uniformly. Clients use the same interface for leaves and composites.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 104,
    "question": "When and why would you use Design Patterns: Composite?",
    "answer": "Use design patterns: composite to improve design quality: Treat part‑whole hierarchies uniformly. Clients use the same interface for leaves and composites.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 105,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Composite?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Treat part‑whole hierarchies uniformly. Clients use the same interface for leaves and composites."
  },
  {
    "id": 106,
    "question": "What is Design Patterns: Observer in OOP?",
    "answer": "Define a one‑to‑many dependency so that observers are notified of subject changes. Useful for GUIs, event systems.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 107,
    "question": "When and why would you use Design Patterns: Observer?",
    "answer": "Use design patterns: observer to improve design quality: Define a one‑to‑many dependency so that observers are notified of subject changes. Useful for GUIs, event systems.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 108,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Observer?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Define a one‑to‑many dependency so that observers are notified of subject changes. Useful for GUIs, event systems."
  },
  {
    "id": 109,
    "question": "What is Design Patterns: Command in OOP?",
    "answer": "Encapsulate a request as an object—supports undo/redo, queuing, logging.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 110,
    "question": "When and why would you use Design Patterns: Command?",
    "answer": "Use design patterns: command to improve design quality: Encapsulate a request as an object—supports undo/redo, queuing, logging.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 111,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Command?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Encapsulate a request as an object—supports undo/redo, queuing, logging."
  },
  {
    "id": 112,
    "question": "What is Design Patterns: State in OOP?",
    "answer": "Allow an object to change its behavior when its internal state changes—appears to change class.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 113,
    "question": "When and why would you use Design Patterns: State?",
    "answer": "Use design patterns: state to improve design quality: Allow an object to change its behavior when its internal state changes—appears to change class.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 114,
    "question": "What are common pitfalls or misconceptions about Design Patterns: State?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Allow an object to change its behavior when its internal state changes—appears to change class."
  },
  {
    "id": 115,
    "question": "What is Design Patterns: Template Method in OOP?",
    "answer": "Define the skeleton of an algorithm in a base class and let subclasses override steps.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 116,
    "question": "When and why would you use Design Patterns: Template Method?",
    "answer": "Use design patterns: template method to improve design quality: Define the skeleton of an algorithm in a base class and let subclasses override steps.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 117,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Template Method?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Define the skeleton of an algorithm in a base class and let subclasses override steps."
  },
  {
    "id": 118,
    "question": "What is Design Patterns: Builder in OOP?",
    "answer": "Construct complex objects step by step. Helps with readability and immutability.\n\nPython:\n\n\nJava:\nnew Person.Builder().name(\"A\").age(3).build();\n\nC++:"
  },
  {
    "id": 119,
    "question": "When and why would you use Design Patterns: Builder?",
    "answer": "Use design patterns: builder to improve design quality: Construct complex objects step by step. Helps with readability and immutability.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 120,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Builder?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Construct complex objects step by step. Helps with readability and immutability."
  },
  {
    "id": 121,
    "question": "What is Design Patterns: Facade in OOP?",
    "answer": "Provide a simple unified interface to a complex subsystem.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 122,
    "question": "When and why would you use Design Patterns: Facade?",
    "answer": "Use design patterns: facade to improve design quality: Provide a simple unified interface to a complex subsystem.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 123,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Facade?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Provide a simple unified interface to a complex subsystem."
  },
  {
    "id": 124,
    "question": "What is Design Patterns: Flyweight in OOP?",
    "answer": "Share intrinsic state to support large numbers of fine‑grained objects efficiently.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 125,
    "question": "When and why would you use Design Patterns: Flyweight?",
    "answer": "Use design patterns: flyweight to improve design quality: Share intrinsic state to support large numbers of fine‑grained objects efficiently.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 126,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Flyweight?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Share intrinsic state to support large numbers of fine‑grained objects efficiently."
  },
  {
    "id": 127,
    "question": "What is Design Patterns: Bridge in OOP?",
    "answer": "Decouple abstraction from implementation so the two can vary independently.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 128,
    "question": "When and why would you use Design Patterns: Bridge?",
    "answer": "Use design patterns: bridge to improve design quality: Decouple abstraction from implementation so the two can vary independently.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 129,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Bridge?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Decouple abstraction from implementation so the two can vary independently."
  },
  {
    "id": 130,
    "question": "What is Design Patterns: Prototype in OOP?",
    "answer": "Create new objects by cloning a prototype. Useful when instantiation is expensive or complex.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 131,
    "question": "When and why would you use Design Patterns: Prototype?",
    "answer": "Use design patterns: prototype to improve design quality: Create new objects by cloning a prototype. Useful when instantiation is expensive or complex.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 132,
    "question": "What are common pitfalls or misconceptions about Design Patterns: Prototype?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Create new objects by cloning a prototype. Useful when instantiation is expensive or complex."
  },
  {
    "id": 133,
    "question": "What is Exception Safety (C++) in OOP?",
    "answer": "Provide strong/basic/no‑throw guarantees. Use RAII, copy‑and‑swap, and avoid resource leaks under exceptions.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 134,
    "question": "When and why would you use Exception Safety (C++)?",
    "answer": "Use exception safety (c++) to improve design quality: Provide strong/basic/no‑throw guarantees. Use RAII, copy‑and‑swap, and avoid resource leaks under exceptions.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 135,
    "question": "What are common pitfalls or misconceptions about Exception Safety (C++)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Provide strong/basic/no‑throw guarantees. Use RAII, copy‑and‑swap, and avoid resource leaks under exceptions."
  },
  {
    "id": 136,
    "question": "What is PIMPL (C++) in OOP?",
    "answer": "Pointer to IMPL hides implementation details, reduces compile times, and preserves ABI stability.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 137,
    "question": "When and why would you use PIMPL (C++)?",
    "answer": "Use pimpl (c++) to improve design quality: Pointer to IMPL hides implementation details, reduces compile times, and preserves ABI stability.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 138,
    "question": "What are common pitfalls or misconceptions about PIMPL (C++)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Pointer to IMPL hides implementation details, reduces compile times, and preserves ABI stability."
  },
  {
    "id": 139,
    "question": "What is Law of Demeter in OOP?",
    "answer": "Only talk to your immediate friends: a method should call methods of itself, its fields, method parameters, or objects it creates—reduces coupling ('don't chain train wrecks').\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 140,
    "question": "When and why would you use Law of Demeter?",
    "answer": "Use law of demeter to improve design quality: Only talk to your immediate friends: a method should call methods of itself, its fields, method parameters, or objects it creates—reduces coupling ('don't chain train wrecks').\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 141,
    "question": "What are common pitfalls or misconceptions about Law of Demeter?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Only talk to your immediate friends: a method should call methods of itself, its fields, method parameters, or objects it creates—reduces coupling ('don't chain train wrecks')."
  },
  {
    "id": 142,
    "question": "What is Tell, Don't Ask in OOP?",
    "answer": "Tell objects what to do, don't ask for data and make decisions externally—push behavior to the objects that own the data.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 143,
    "question": "When and why would you use Tell, Don't Ask?",
    "answer": "Use tell, don't ask to improve design quality: Tell objects what to do, don't ask for data and make decisions externally—push behavior to the objects that own the data.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 144,
    "question": "What are common pitfalls or misconceptions about Tell, Don't Ask?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Tell objects what to do, don't ask for data and make decisions externally—push behavior to the objects that own the data."
  },
  {
    "id": 145,
    "question": "What is Value vs Reference semantics in OOP?",
    "answer": "C++ value types copy by value (cheap with move/NRVO); Java/Python variables hold references to objects. Understand aliasing and copying costs.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 146,
    "question": "When and why would you use Value vs Reference semantics?",
    "answer": "Use value vs reference semantics to improve design quality: C++ value types copy by value (cheap with move/NRVO); Java/Python variables hold references to objects. Understand aliasing and copying costs.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 147,
    "question": "What are common pitfalls or misconceptions about Value vs Reference semantics?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: C++ value types copy by value (cheap with move/NRVO); Java/Python variables hold references to objects. Understand aliasing and copying costs."
  },
  {
    "id": 148,
    "question": "What is Sealed Classes / Algebraic Hierarchies in OOP?",
    "answer": "Constrain subclassing to a known set (Java sealed classes). Improves exhaustiveness and pattern matching with polymorphism.\n\nPython:\n\n\nJava:\nsealed interface Shape permits Circle, Rect {}\n\nC++:"
  },
  {
    "id": 149,
    "question": "When and why would you use Sealed Classes / Algebraic Hierarchies?",
    "answer": "Use sealed classes / algebraic hierarchies to improve design quality: Constrain subclassing to a known set (Java sealed classes). Improves exhaustiveness and pattern matching with polymorphism.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 150,
    "question": "What are common pitfalls or misconceptions about Sealed Classes / Algebraic Hierarchies?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Constrain subclassing to a known set (Java sealed classes). Improves exhaustiveness and pattern matching with polymorphism."
  },
  {
    "id": 151,
    "question": "What is Mixins & Traits in OOP?",
    "answer": "Reuse behavior via mixins (Python) or traits (some languages). Keep them small and orthogonal; avoid stateful mixins.\n\nPython:\nclass JSONMixin: def to_json(self): ...\n\nJava:\n\n\nC++:\ntemplate<class T> struct Comparable { bool operator<(const T&) const; };"
  },
  {
    "id": 152,
    "question": "When and why would you use Mixins & Traits?",
    "answer": "Use mixins & traits to improve design quality: Reuse behavior via mixins (Python) or traits (some languages). Keep them small and orthogonal; avoid stateful mixins.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 153,
    "question": "What are common pitfalls or misconceptions about Mixins & Traits?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Reuse behavior via mixins (Python) or traits (some languages). Keep them small and orthogonal; avoid stateful mixins."
  },
  {
    "id": 154,
    "question": "What is Duck Typing vs Nominal Typing in OOP?",
    "answer": "Duck typing (Python) cares about behavior, not declared types; nominal typing (Java/C++) relies on declared types and hierarchies.\n\nPython:\ndef quack(x): x.quack()  # works if object has quack()\n\nJava:\n\n\nC++:"
  },
  {
    "id": 155,
    "question": "When and why would you use Duck Typing vs Nominal Typing?",
    "answer": "Use duck typing vs nominal typing to improve design quality: Duck typing (Python) cares about behavior, not declared types; nominal typing (Java/C++) relies on declared types and hierarchies.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 156,
    "question": "What are common pitfalls or misconceptions about Duck Typing vs Nominal Typing?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Duck typing (Python) cares about behavior, not declared types; nominal typing (Java/C++) relies on declared types and hierarchies."
  },
  {
    "id": 157,
    "question": "What is abc/Protocol (Python) in OOP?",
    "answer": "abc.ABC defines nominal abstract bases; typing.Protocol defines structural interfaces checked by type checkers (PEP 544).\n\nPython:\nclass Sized(Protocol):\n    def __len__(self) -> int: ...\n\nJava:\n\n\nC++:"
  },
  {
    "id": 158,
    "question": "When and why would you use abc/Protocol (Python)?",
    "answer": "Use abc/protocol (python) to improve design quality: abc.ABC defines nominal abstract bases; typing.Protocol defines structural interfaces checked by type checkers (PEP 544).\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 159,
    "question": "What are common pitfalls or misconceptions about abc/Protocol (Python)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: abc.ABC defines nominal abstract bases; typing.Protocol defines structural interfaces checked by type checkers (PEP 544)."
  },
  {
    "id": 160,
    "question": "What is Data classes (Python/Java) in OOP?",
    "answer": "Generate boilerplate (equals/hash, toString, etc.). Python dataclasses and Java records make value objects concise.\n\nPython:\n@dataclass\nclass Point: x:int; y:int\n\nJava:\nrecord Point(int x, int y) {}\n\nC++:"
  },
  {
    "id": 161,
    "question": "When and why would you use Data classes (Python/Java)?",
    "answer": "Use data classes (python/java) to improve design quality: Generate boilerplate (equals/hash, toString, etc.). Python dataclasses and Java records make value objects concise.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 162,
    "question": "What are common pitfalls or misconceptions about Data classes (Python/Java)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Generate boilerplate (equals/hash, toString, etc.). Python dataclasses and Java records make value objects concise."
  },
  {
    "id": 163,
    "question": "What is Copy elision & moves (C++) in OOP?",
    "answer": "Compilers can elide copies (NRVO). Moves transfer resources cheaply. Design types to be movable when possible.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 164,
    "question": "When and why would you use Copy elision & moves (C++)?",
    "answer": "Use copy elision & moves (c++) to improve design quality: Compilers can elide copies (NRVO). Moves transfer resources cheaply. Design types to be movable when possible.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 165,
    "question": "What are common pitfalls or misconceptions about Copy elision & moves (C++)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Compilers can elide copies (NRVO). Moves transfer resources cheaply. Design types to be movable when possible."
  },
  {
    "id": 166,
    "question": "What is super vs overrides (Java/Python) in OOP?",
    "answer": "Use super to call base behavior; ensure cooperative multiple inheritance in Python; in Java, super.method() explicitly calls parent implementation.\n\nPython:\nclass B(A):\n    def f(self): super().f(); ...\n\nJava:\nclass B extends A { void f(){ super.f(); ... } }\n\nC++:"
  },
  {
    "id": 167,
    "question": "When and why would you use super vs overrides (Java/Python)?",
    "answer": "Use super vs overrides (java/python) to improve design quality: Use super to call base behavior; ensure cooperative multiple inheritance in Python; in Java, super.method() explicitly calls parent implementation.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 168,
    "question": "What are common pitfalls or misconceptions about super vs overrides (Java/Python)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Use super to call base behavior; ensure cooperative multiple inheritance in Python; in Java, super.method() explicitly calls parent implementation."
  },
  {
    "id": 169,
    "question": "What is Final/sealed methods in OOP?",
    "answer": "Final methods/classes can’t be overridden/subclassed. Use to lock down invariants or for security/performance.\n\nPython:\n\n\nJava:\nfinal class Util {} // cannot extend\n\nC++:\nstruct A{ virtual void f() final; };"
  },
  {
    "id": 170,
    "question": "When and why would you use Final/sealed methods?",
    "answer": "Use final/sealed methods to improve design quality: Final methods/classes can’t be overridden/subclassed. Use to lock down invariants or for security/performance.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 171,
    "question": "What are common pitfalls or misconceptions about Final/sealed methods?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Final methods/classes can’t be overridden/subclassed. Use to lock down invariants or for security/performance."
  },
  {
    "id": 172,
    "question": "What is Serialization & versioning in OOP?",
    "answer": "Be explicit about serialized forms; add versioning; prefer explicit DTOs over exposing domain entities.\n\nPython:\ndataclasses.asdict(obj)  # custom encoders\n\nJava:\nimplements Serializable with serialVersionUID\n\nC++:\nUse non‑intrusive serializers (e.g., cereal)"
  },
  {
    "id": 173,
    "question": "When and why would you use Serialization & versioning?",
    "answer": "Use serialization & versioning to improve design quality: Be explicit about serialized forms; add versioning; prefer explicit DTOs over exposing domain entities.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 174,
    "question": "What are common pitfalls or misconceptions about Serialization & versioning?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Be explicit about serialized forms; add versioning; prefer explicit DTOs over exposing domain entities."
  },
  {
    "id": 175,
    "question": "What is Thread safety & confinement in OOP?",
    "answer": "Prefer immutability, confinement (thread‑local ownership), and thread‑safe designs. Guard shared mutable state with synchronization or lock‑free structures.\n\nPython:\nUse queues, GIL still needs care with I/O and C extensions\n\nJava:\nsynchronized/locks/atomics, immutable objects\n\nC++:\nstd::mutex, atomic, const‑correctness"
  },
  {
    "id": 176,
    "question": "When and why would you use Thread safety & confinement?",
    "answer": "Use thread safety & confinement to improve design quality: Prefer immutability, confinement (thread‑local ownership), and thread‑safe designs. Guard shared mutable state with synchronization or lock‑free structures.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 177,
    "question": "What are common pitfalls or misconceptions about Thread safety & confinement?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Prefer immutability, confinement (thread‑local ownership), and thread‑safe designs. Guard shared mutable state with synchronization or lock‑free structures."
  },
  {
    "id": 178,
    "question": "What is Cohesion & Coupling in OOP?",
    "answer": "Aim for high cohesion (related responsibilities in one place) and low coupling (few, stable dependencies).\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 179,
    "question": "When and why would you use Cohesion & Coupling?",
    "answer": "Use cohesion & coupling to improve design quality: Aim for high cohesion (related responsibilities in one place) and low coupling (few, stable dependencies).\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 180,
    "question": "What are common pitfalls or misconceptions about Cohesion & Coupling?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Aim for high cohesion (related responsibilities in one place) and low coupling (few, stable dependencies)."
  },
  {
    "id": 181,
    "question": "What is Code Smells vs Refactorings in OOP?",
    "answer": "Long class, feature envy, shotgun surgery, god object, message chains. Refactor via extract class, move method, introduce interface, replace inheritance with delegation.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 182,
    "question": "When and why would you use Code Smells vs Refactorings?",
    "answer": "Use code smells vs refactorings to improve design quality: Long class, feature envy, shotgun surgery, god object, message chains. Refactor via extract class, move method, introduce interface, replace inheritance with delegation.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 183,
    "question": "What are common pitfalls or misconceptions about Code Smells vs Refactorings?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Long class, feature envy, shotgun surgery, god object, message chains. Refactor via extract class, move method, introduce interface, replace inheritance with delegation."
  },
  {
    "id": 184,
    "question": "What is Testing OO code in OOP?",
    "answer": "Prefer testing behavior via public interfaces. Use fakes/stubs over mocks where possible; mock external boundaries. Design for testability with DI.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 185,
    "question": "When and why would you use Testing OO code?",
    "answer": "Use testing oo code to improve design quality: Prefer testing behavior via public interfaces. Use fakes/stubs over mocks where possible; mock external boundaries. Design for testability with DI.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 186,
    "question": "What are common pitfalls or misconceptions about Testing OO code?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Prefer testing behavior via public interfaces. Use fakes/stubs over mocks where possible; mock external boundaries. Design for testability with DI."
  },
  {
    "id": 187,
    "question": "What is Open Recursion & Self in OOP?",
    "answer": "Methods are late‑bound (open recursion); 'self/this' is passed implicitly enabling overriding to affect internal calls. Beware calling overridable methods from constructors.\n\nPython:\n\n\nJava:\nAvoid calling overridable methods in constructors.\n\nC++:"
  },
  {
    "id": 188,
    "question": "When and why would you use Open Recursion & Self?",
    "answer": "Use open recursion & self to improve design quality: Methods are late‑bound (open recursion); 'self/this' is passed implicitly enabling overriding to affect internal calls. Beware calling overridable methods from constructors.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 189,
    "question": "What are common pitfalls or misconceptions about Open Recursion & Self?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Methods are late‑bound (open recursion); 'self/this' is passed implicitly enabling overriding to affect internal calls. Beware calling overridable methods from constructors."
  },
  {
    "id": 190,
    "question": "What is Invariant & Representation exposure in OOP?",
    "answer": "Keep invariants consistent; avoid exposing internal representation (defensive copies, unmodifiable views).\n\nPython:\n\n\nJava:\nCollections.unmodifiableList(list)\n\nC++:"
  },
  {
    "id": 191,
    "question": "When and why would you use Invariant & Representation exposure?",
    "answer": "Use invariant & representation exposure to improve design quality: Keep invariants consistent; avoid exposing internal representation (defensive copies, unmodifiable views).\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 192,
    "question": "What are common pitfalls or misconceptions about Invariant & Representation exposure?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Keep invariants consistent; avoid exposing internal representation (defensive copies, unmodifiable views)."
  },
  {
    "id": 193,
    "question": "What is Value Objects vs Entities in OOP?",
    "answer": "Value objects are defined by their attributes and are immutable; entities have identity that persists through changes. Treat value objects as replace-not-mutate.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 194,
    "question": "When and why would you use Value Objects vs Entities?",
    "answer": "Use value objects vs entities to improve design quality: Value objects are defined by their attributes and are immutable; entities have identity that persists through changes. Treat value objects as replace-not-mutate.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 195,
    "question": "What are common pitfalls or misconceptions about Value Objects vs Entities?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Value objects are defined by their attributes and are immutable; entities have identity that persists through changes. Treat value objects as replace-not-mutate."
  },
  {
    "id": 196,
    "question": "What is Aggregate/Bounded Context (OO & DDD) in OOP?",
    "answer": "Aggregate enforces invariants across a cluster of objects with a root controlling access; keep references from outside only to the root.\n\nPython:\n\n\nJava:\n\n\nC++:"
  },
  {
    "id": 197,
    "question": "When and why would you use Aggregate/Bounded Context (OO & DDD)?",
    "answer": "Use aggregate/bounded context (oo & ddd) to improve design quality: Aggregate enforces invariants across a cluster of objects with a root controlling access; keep references from outside only to the root.\nIt reduces defects by clarifying responsibilities and contracts."
  },
  {
    "id": 198,
    "question": "What are common pitfalls or misconceptions about Aggregate/Bounded Context (OO & DDD)?",
    "answer": "Common pitfalls: overuse, confusing it with unrelated concepts, and ignoring trade‑offs. Remember: Aggregate enforces invariants across a cluster of objects with a root controlling access; keep references from outside only to the root."
  },
  {
    "id": 199,
    "question": "What is the Observer pattern and when would you use it?",
    "answer": "Define a one‑to‑many dependency so observers are notified on state changes. Implement subscribe/notify; avoid memory leaks by weak references or clear detach APIs."
  },
  {
    "id": 200,
    "question": "What is the Decorator pattern and when would you use it?",
    "answer": "Attach additional responsibilities to an object dynamically; provides a flexible alternative to subclassing for extending behavior."
  },
  {
    "id": 201,
    "question": "What is the Adapter pattern and when would you use it?",
    "answer": "Convert one interface to another expected by clients without changing the underlying class."
  },
  {
    "id": 202,
    "question": "What is the Proxy pattern and when would you use it?",
    "answer": "Provide a surrogate for another object to control access or add behavior like caching or remote access."
  },
  {
    "id": 203,
    "question": "What is the Composite pattern and when would you use it?",
    "answer": "Compose objects into tree structures to represent part‑whole hierarchies and let clients treat individual and composite objects uniformly."
  },
  {
    "id": 204,
    "question": "What is the Command pattern and when would you use it?",
    "answer": "Encapsulate a request as an object, allowing parameterization, queuing, logging, and undo/redo."
  },
  {
    "id": 205,
    "question": "What is the State pattern and when would you use it?",
    "answer": "Allow an object to alter its behavior when its internal state changes; each state is a separate class."
  },
  {
    "id": 206,
    "question": "What is the Strategy pattern and when would you use it?",
    "answer": "Define a family of algorithms and make them interchangeable; the algorithm varies independently from clients."
  },
  {
    "id": 207,
    "question": "What is the Template Method pattern and when would you use it?",
    "answer": "Define the skeleton of an algorithm and defer some steps to subclasses."
  },
  {
    "id": 208,
    "question": "What is the Builder pattern and when would you use it?",
    "answer": "Separate construction of a complex object from its representation so the same construction can create different representations."
  },
  {
    "id": 209,
    "question": "What is the Facade pattern and when would you use it?",
    "answer": "Provide a unified, simplified interface to a set of interfaces in a subsystem."
  },
  {
    "id": 210,
    "question": "What is the Flyweight pattern and when would you use it?",
    "answer": "Use sharing to support large numbers of fine‑grained objects efficiently; separate intrinsic and extrinsic state."
  },
  {
    "id": 211,
    "question": "What is the Bridge pattern and when would you use it?",
    "answer": "Decouple an abstraction from its implementation so they can vary independently."
  },
  {
    "id": 212,
    "question": "What is the Prototype pattern and when would you use it?",
    "answer": "Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype."
  },
  {
    "id": 213,
    "question": "What is the difference between @staticmethod and @classmethod in Python OOP?",
    "answer": "@staticmethod is a namespaced function that does not receive the class or instance. @classmethod receives the class (cls) and is useful for alternate constructors or class‑level behavior. Neither can access instance state unless given an instance."
  },
  {
    "id": 214,
    "question": "How does Python support encapsulation without true private fields?",
    "answer": "Python uses naming conventions: _single for internal use and __double for name‑mangling to avoid accidental override. True privacy relies on convention; enforce via properties and modules, not only names."
  },
  {
    "id": 215,
    "question": "Explain Python's dataclasses and how they help OO design.",
    "answer": "dataclasses auto‑generate __init__, __repr__, __eq__, and more for simple data holders; with frozen=True they become immutable value objects. They reduce boilerplate and clarify intent."
  },
  {
    "id": 216,
    "question": "Why should equals and hashCode be overridden together in Java?",
    "answer": "Because the general contract of hash‑based collections requires that equal objects have equal hash codes. Violating this breaks lookups in HashMap/HashSet and leads to subtle bugs."
  },
  {
    "id": 217,
    "question": "What are sealed classes in Java and why use them?",
    "answer": "Sealed classes/interfaces limit which classes can extend or implement them, improving exhaustiveness and enabling safer polymorphic handling (e.g., switch expressions)."
  },
  {
    "id": 218,
    "question": "What is the difference between interface default methods and abstract classes?",
    "answer": "Default methods add behavior to interfaces, but interfaces can't hold state (beyond constants). Abstract classes can hold state and constructors. Favor interfaces for capabilities; abstract classes for shared partial implementation."
  },
  {
    "id": 219,
    "question": "Why must base classes in C++ have virtual destructors?",
    "answer": "Deleting a derived object through a base pointer without a virtual destructor is undefined behavior. A virtual destructor ensures the derived destructor runs and resources are released."
  },
  {
    "id": 220,
    "question": "Explain the Rule of Five and when to use it.",
    "answer": "If a type manages resources, define or delete: destructor, copy ctor, copy assignment, move ctor, move assignment. If default semantics suffice, prefer Rule of Zero."
  },
  {
    "id": 221,
    "question": "What is slicing in C++ OOP and how to avoid it?",
    "answer": "Object slicing occurs when a derived object is copied into a base object by value, losing derived state. Avoid by using references/pointers to base or making types non‑copyable."
  },
  {
    "id": 222,
    "question": "What is polymorphism in object-oriented programming?",
    "answer": "Polymorphism means 'many forms' - the ability of objects of different types to respond to the same interface. In OOP, it allows code to work with objects of different classes through a common interface. Types include compile-time (method overloading, operator overloading) and runtime polymorphism (method overriding via virtual functions)."
  },
  {
    "id": 223,
    "question": "Explain the difference between compile-time and runtime polymorphism.",
    "answer": "Compile-time polymorphism (static binding) is resolved during compilation - method overloading and operator overloading. Runtime polymorphism (dynamic binding) is resolved at runtime via virtual functions and inheritance. Example: compile-time: add(int,int) vs add(double,double); runtime: Shape* s = new Circle(); s->draw() calls Circle's draw()."
  },
  {
    "id": 224,
    "question": "What is method overloading and how does it achieve polymorphism?",
    "answer": "Method overloading allows multiple methods with same name but different parameters (number, type, order) in the same class. It's compile-time polymorphism. Example: void print(int i); void print(double d); void print(string s); Compiler decides which to call based on arguments. Return type alone cannot distinguish overloads."
  },
  {
    "id": 225,
    "question": "Explain method overriding with an example.",
    "answer": "Method overriding occurs when a subclass provides its own implementation of a method already defined in parent class. Enables runtime polymorphism. Example: class Animal { virtual void speak() { cout << 'Animal speaks'; } }; class Dog : public Animal { void speak() override { cout << 'Dog barks'; } }; Animal* a = new Dog(); a->speak(); // Calls Dog's speak."
  },
  {
    "id": 226,
    "question": "What is the difference between overloading and overriding?",
    "answer": "Overloading: same class, same method name, different parameters, compile-time binding, may have different return types. Overriding: different classes (inheritance), same signature, runtime binding via virtual functions, return type must be covariant. Overloading adds behavior; overriding replaces behavior."
  },
  {
    "id": 227,
    "question": "How does virtual functions enable runtime polymorphism in C++?",
    "answer": "Virtual functions allow derived class methods to be called through base class pointers/references. Compiler adds vptr (virtual pointer) to objects, pointing to vtable (virtual table) containing function pointers. At runtime, vptr is used to call correct function. Example: class Base { public: virtual void show() { cout << 'Base'; } }; class Derived : public Base { void show() override { cout << 'Derived'; } }; Base* b = new Derived(); b->show(); // Prints 'Derived'"
  },
  {
    "id": 228,
    "question": "What is the role of virtual table (vtable) in polymorphism?",
    "answer": "Vtable is a static array of function pointers created per class with virtual functions. Each object has a hidden vptr pointing to its class's vtable. When virtual function called, program follows vptr to vtable, then to correct function. Enables dynamic dispatch with minimal overhead (one pointer indirection)."
  },
  {
    "id": 229,
    "question": "Explain the concept of virtual destructors in C++.",
    "answer": "Virtual destructors ensure proper cleanup when deleting derived objects through base pointers. If base destructor non-virtual, only base destructor runs, causing resource leaks. Example: class Base { public: virtual ~Base() {} }; class Derived : public Base { ~Derived() { /* cleanup derived resources */ } }; Base* b = new Derived(); delete b; // Both destructors called."
  },
  {
    "id": 230,
    "question": "What is pure virtual function and abstract class?",
    "answer": "Pure virtual function is declared with '= 0' in C++, making class abstract (cannot instantiate). Derived classes must override it to become concrete. Example: class Shape { public: virtual double area() = 0; }; class Circle : public Shape { double area() override { return 3.14 * r * r; } }; Abstract classes define interfaces."
  },
  {
    "id": 231,
    "question": "Explain the concept of covariant return types in overriding.",
    "answer": "Covariant return types allow overridden method to return more specific type than base method. Example: class Base { virtual Base* clone(); }; class Derived : public Base { Derived* clone() override; }; Allowed because Derived* is substitutable for Base*. Maintains type safety while enabling more precise interfaces."
  },
  {
    "id": 232,
    "question": "What is the difference between early binding and late binding?",
    "answer": "Early binding (static binding) resolved at compile time - function calls linked directly. Faster but inflexible. Used for non-virtual functions, overloaded functions. Late binding (dynamic binding) resolved at runtime via virtual functions - function determined by object type. Slight overhead but enables polymorphism. Virtual functions, interface methods use late binding."
  },
  {
    "id": 233,
    "question": "How does Java implement polymorphism?",
    "answer": "Java implements polymorphism through method overriding (runtime polymorphism) and method overloading (compile-time). All non-static, non-final, non-private methods are virtual by default. Uses late binding for overridden methods. Interfaces provide polymorphic behavior across unrelated classes. Example: List<String> list = new ArrayList<>(); // Polymorphic reference."
  },
  {
    "id": 234,
    "question": "Explain the concept of duck typing in Python as polymorphism.",
    "answer": "Duck typing ('If it walks like a duck and quacks like a duck, it's a duck') means objects are considered based on behavior, not type. Python polymorphism through duck typing: def process(obj): obj.quack() # Works if obj has quack() method. No inheritance needed. More flexible but less explicit than nominal typing."
  },
  {
    "id": 235,
    "question": "What is parametric polymorphism (generics/templates)?",
    "answer": "Parametric polymorphism allows code to work with any type through type parameters. C++ templates: template<typename T> T max(T a, T b) { return a > b ? a : b; } Java generics: class Box<T> { T value; } Python type hints: def identity[T](x: T) -> T: return x. Enables type-safe reusable code."
  },
  {
    "id": 236,
    "question": "Explain the difference between subtype polymorphism and parametric polymorphism.",
    "answer": "Subtype polymorphism (inclusion polymorphism) uses inheritance - objects of different types through common base. Parametric polymorphism uses type parameters - same code works for any type. Subtype: Shape* s = getShape(); s->draw(); Parametric: vector<int> vi; vector<string> vs; Both provide flexibility but different mechanisms."
  },
  {
    "id": 237,
    "question": "What is the Liskov Substitution Principle and its relation to polymorphism?",
    "answer": "LSP states that objects of a superclass should be replaceable with objects of a subclass without affecting program correctness. Foundation for safe polymorphism. Violation: Square inheriting from Rectangle with separate setWidth/setHeight breaks substitution. Proper polymorphism requires subtypes maintain base class contracts."
  },
  {
    "id": 238,
    "question": "How does C++ achieve compile-time polymorphism with templates?",
    "answer": "Templates provide compile-time polymorphism through code generation. Different types generate different code, resolved during compilation. Example: template<typename T> T add(T a, T b) { return a + b; } add(5,3) generates int version; add(5.2,3.1) generates double version. Faster than runtime polymorphism but increases code size."
  },
  {
    "id": 239,
    "question": "Explain the concept of dynamic dispatch in polymorphism.",
    "answer": "Dynamic dispatch selects which method to call at runtime based on object's actual type. Virtual functions in C++, all instance methods in Java/Python (except final/private). Implemented via vtables or similar mechanisms. Enables polymorphic behavior but adds slight overhead compared to static dispatch."
  },
  {
    "id": 240,
    "question": "What is the difference between polymorphism and method overloading?",
    "answer": "Polymorphism (specifically subtype/runtime) allows objects of different types to respond to same interface, resolved at runtime. Overloading is multiple methods same name different parameters, resolved at compile time. Overloading within same class; polymorphism across inheritance hierarchy. Both provide flexibility but different mechanisms and timing."
  },
  {
    "id": 241,
    "question": "Explain the concept of ad-hoc polymorphism with examples.",
    "answer": "Ad-hoc polymorphism allows same function name to work with different types through separate implementations. Includes function overloading and operator overloading. Example: print(int), print(string), print(vector<int>) - each has separate implementation. Contrast with parametric polymorphism (same code for all types) and subtype polymorphism (inheritance-based)."
  },
  {
    "id": 242,
    "question": "What is the role of the 'virtual' keyword in C++ polymorphism?",
    "answer": "'virtual' enables runtime polymorphism by telling compiler to use dynamic dispatch. Virtual functions can be overridden in derived classes. Virtual destructors ensure proper cleanup. Pure virtual (=0) makes class abstract. Without virtual, function calls resolved statically based on pointer type, not object type."
  },
  {
    "id": 243,
    "question": "Explain the concept of multiple dispatch (multimethods).",
    "answer": "Multiple dispatch selects method based on runtime types of multiple arguments. Single dispatch (typical OOP) uses only receiver type. C++ virtual functions are single dispatch. Python with functools.singledispatch provides single dispatch on first argument. Multiple dispatch useful for operations like collision detection (two objects of unknown types)."
  },
  {
    "id": 244,
    "question": "How does polymorphism support the Open/Closed Principle?",
    "answer": "OCP states classes open for extension, closed for modification. Polymorphism enables adding new behavior through new derived classes without changing existing code. Example: Shape hierarchy with draw() - add Triangle class without modifying drawing code that works with Shape*. New functionality through extension, not modification."
  },
  {
    "id": 245,
    "question": "What is the performance cost of polymorphism?",
    "answer": "Runtime polymorphism costs: vtable pointer per object (memory), indirect function call (one extra indirection), prevents inlining in many cases. Virtual function call ~2-3x slower than direct call. Compile-time polymorphism (templates) has no runtime cost but increases code size. Trade-off between flexibility and performance."
  },
  {
    "id": 246,
    "question": "Explain the concept of polymorphic copy construction.",
    "answer": "Polymorphic copying requires virtual clone method because copy constructor can't be virtual. Example: class Base { public: virtual Base* clone() const = 0; }; class Derived : public Base { Derived* clone() const override { return new Derived(*this); } }; Base* b1 = new Derived(); Base* b2 = b1->clone(); // Copies correct type."
  },
  {
    "id": 247,
    "question": "What is the difference between static polymorphism and dynamic polymorphism?",
    "answer": "Static polymorphism (compile-time): templates, overloading - resolved during compilation, faster, no runtime overhead, but less flexible. Dynamic polymorphism (runtime): virtual functions, interfaces - resolved at runtime via dynamic dispatch, flexible, enables plugins and runtime decisions, slight overhead. Each suited for different scenarios."
  },
  {
    "id": 248,
    "question": "How does Python achieve polymorphism without explicit interfaces?",
    "answer": "Python uses duck typing - objects are polymorphic if they implement required methods. No explicit inheritance needed. Example: def process(obj): obj.save() # Works if obj has save() method. Also supports nominal polymorphism through ABC (Abstract Base Classes) and inheritance. More flexible but less explicit than static typing."
  },
  {
    "id": 249,
    "question": "Explain the concept of CRTP (Curiously Recurring Template Pattern) for static polymorphism.",
    "answer": "CRTP achieves static polymorphism in C++: template<typename Derived> class Base { void interface() { static_cast<Derived*>(this)->implementation(); } }; class Derived : Base<Derived> { void implementation(); }; All calls resolved at compile time, no virtual overhead. Used for mixins, policy-based design, optimizing polymorphic calls."
  },
  {
    "id": 250,
    "question": "What is the relationship between polymorphism and dependency injection?",
    "answer": "Dependency injection relies on polymorphism - injecting dependencies through interfaces allows swapping implementations. Example: class Service { private: IRepository repo; public: Service(IRepository r) : repo(r) {} }; Can inject SqlRepository or MockRepository polymorphically. Enables loose coupling, testing, configuration."
  },
  {
    "id": 251,
    "question": "Explain the concept of polymorphic value types in modern C++.",
    "answer": "C++17 std::variant and std::visit provide polymorphic-like behavior for value types without inheritance. std::variant<int, double, string> v; std::visit([](auto&& arg) { cout << arg; }, v); Combined with std::holds_alternative, enables type-safe unions with visitor pattern. Alternative to inheritance-based polymorphism for fixed type sets."
  },
  {
    "id": 252,
    "question": "What are virtual functions ?",
    "answer": "Virtual functions are member functions declared with 'virtual' keyword that can be overridden in derived classes. They enable runtime polymorphism - the function called is determined by object's actual type, not pointer/reference type. Virtual functions use dynamic dispatch via vtables. Example: class Base { public: virtual void show() { cout << 'Base'; } };"
  },
  {
    "id": 253,
    "question": "Explain how vtables (virtual tables) work in C++.",
    "answer": "Each class with virtual functions has a static vtable - array of function pointers. Each object has a hidden vptr pointing to its class's vtable. Virtual function call: obj.vptr->vtable[index](). Constructor sets vptr to class's vtable. Multiple inheritance creates multiple vptrs. Enables efficient dynamic dispatch with minimal overhead."
  },
  {
    "id": 254,
    "question": "What is the difference between virtual and non-virtual functions?",
    "answer": "Virtual functions support dynamic binding - resolved at runtime based on object type. Non-virtual functions use static binding - resolved at compile time based on pointer/reference type. Virtual functions have slight overhead (vptr, indirect call) but enable polymorphism. Non-virtual faster but inflexible. Virtual destructors essential for proper cleanup."
  },
  {
    "id": 255,
    "question": "Explain the concept of pure virtual functions and abstract classes.",
    "answer": "Pure virtual function declared with '= 0' (C++) or 'abstract' (C#/Java). Makes class abstract - cannot instantiate. Derived classes must override pure virtuals to become concrete. Example: class Shape { public: virtual double area() = 0; }; Abstract classes define interfaces, provide common base for polymorphic hierarchies."
  },
  {
    "id": 256,
    "question": "Why should destructors be virtual in polymorphic base classes?",
    "answer": "Virtual destructors ensure proper cleanup when deleting derived objects through base pointers. Without virtual, only base destructor runs, causing resource leaks in derived class. Example: Base* b = new Derived(); delete b; // Calls ~Derived() then ~Base() if virtual, else only ~Base(). Always make base class destructor virtual."
  },
  {
    "id": 257,
    "question": "What is the cost of virtual functions in C++?",
    "answer": "Virtual function costs: per-object vptr (typically 8 bytes on 64-bit), per-class vtable, indirect function call (can't be inlined), prevents some optimizations. Virtual call ~2-3x slower than direct call. Construction sets vptr. Virtual functions in tight loops can impact performance. Consider non-virtual alternatives for performance-critical code."
  },
  {
    "id": 258,
    "question": "Explain the concept of virtual inheritance and the diamond problem.",
    "answer": "Virtual inheritance solves diamond problem in multiple inheritance where a class inherits from two classes sharing common base. Without virtual, duplicate base subobjects cause ambiguity. Virtual inheritance (virtual base) ensures single shared base instance. Example: class A {}; class B : virtual public A {}; class C : virtual public A {}; class D : public B, public C {}; // Single A subobject."
  },
  {
    "id": 259,
    "question": "How does C++ resolve virtual function calls?",
    "answer": "Compiler generates vtable per class with virtual functions. Constructor sets vptr to appropriate vtable. Virtual call: (obj.vptr[ index ] )(). Index determined at compile time. Runtime: fetch vptr, get function pointer from vtable at index, call through pointer. Multiple inheritance: adjust 'this' pointer for second/third base classes."
  },
  {
    "id": 260,
    "question": "What is the difference between override and final specifiers in C++11?",
    "answer": "'override' explicitly marks overridden virtual function, compiler checks base class has matching virtual. Prevents accidental overloads. 'final' prevents further overriding in derived classes. Example: class Derived : public Base { void func() override; // ensures overriding }; class Derived2 : public Derived { void func() final; // no further override };"
  },
  {
    "id": 261,
    "question": "Explain virtual functions in constructors and destructors.",
    "answer": "In constructors, virtual functions call the version from current class, not derived (derived not yet constructed). Same in destructors (derived already destroyed). Because vptr updated as construction/destruction proceeds. Never call virtual functions in constructors/destructors if expecting polymorphic behavior - leads to surprises."
  },
  {
    "id": 262,
    "question": "What is the slicing problem and how does it relate to virtual functions?",
    "answer": "Slicing occurs when derived object assigned to base object by value - derived part 'sliced off'. Virtual functions called through sliced object use base class versions. Example: Base b = Derived(); b.virtualFunc(); // Calls Base::virtualFunc, not Derived. Avoid by using pointers/references, disable copying, or use polymorphic wrappers."
  },
  {
    "id": 263,
    "question": "Explain the concept of covariant return types with virtual functions.",
    "answer": "Covariant return types allow overridden virtual function to return more specific type. Example: class Base { virtual Base* clone(); }; class Derived : public Base { Derived* clone() override; }; Allowed because Derived* is substitutable for Base*. Maintains type safety while enabling more precise interfaces in hierarchies."
  },
  {
    "id": 264,
    "question": "How are virtual functions implemented in languages without pointers (Java/C#)?",
    "answer": "Java/C# use similar vtable mechanism but managed. All non-static, non-final, non-private methods are virtual by default. Objects have hidden type pointer to method table. Just-In-Time compilation can devirtualize when possible. Reflection provides runtime type information. Garbage collection handles memory, no destructor issues."
  },
  {
    "id": 265,
    "question": "What is the difference between dynamic_cast and virtual functions?",
    "answer": "dynamic_cast uses RTTI (Run-Time Type Information) to safely downcast polymorphic types. Requires at least one virtual function. Virtual functions enable polymorphic behavior without casting. dynamic_cast: Base* b = new Derived(); Derived* d = dynamic_cast<Derived*>(b); Returns null if cast fails. Virtual functions preferred over casting for polymorphic behavior."
  },
  {
    "id": 266,
    "question": "Explain the concept of virtual table pointers (vptr) layout in memory.",
    "answer": "vptr typically stored at beginning of object (implementation-dependent). Size of pointer (4/8 bytes). Each object has vptr(s) - one per polymorphic base in multiple inheritance. vptr points to class-specific vtable. Constructor sets vptr. Object memory layout: [vptr][member variables]. Affects object size and alignment."
  },
  {
    "id": 267,
    "question": "What is the relationship between virtual functions and the Open/Closed Principle?",
    "answer": "Virtual functions enable Open/Closed Principle - classes open for extension via new derived classes, closed for modification. Base class defines virtual interface, derived classes provide implementations. New functionality added without modifying existing code. Example: Shape with virtual draw() - add Triangle without changing code using Shape*."
  },
  {
    "id": 268,
    "question": "How does multiple inheritance affect virtual function tables?",
    "answer": "Multiple inheritance creates multiple vptrs in object - one per polymorphic base class. Each base has its own vtable. Derived class may need to adjust 'this' pointer when calling virtual functions through second/third base. Thunk functions adjust 'this' then jump to implementation. More complex layout, larger objects."
  },
  {
    "id": 269,
    "question": "Explain the concept of virtual base classes and their impact on vtables.",
    "answer": "Virtual base classes solve diamond problem. Implementation adds indirection - objects have pointers to virtual base subobject rather than embedding it directly. Vtables include offsets to virtual bases. More complex, slightly slower access. Constructor responsibilities increase - most derived initializes virtual bases."
  },
  {
    "id": 270,
    "question": "What is the performance overhead of virtual inheritance compared to virtual functions?",
    "answer": "Virtual inheritance adds more overhead than regular virtual functions: additional indirection for accessing virtual base members, more complex construction, larger objects (pointers to virtual bases). Virtual functions: one indirection per call. Virtual inheritance: may add indirection per member access to virtual base. Use only when necessary."
  },
  {
    "id": 271,
    "question": "How do you call a base class virtual function from derived?",
    "answer": "Use scope resolution: Base::function(). Example: class Derived : public Base { void func() override { Base::func(); // Call base version // Additional derived behavior } }; Bypasses virtual dispatch, calls specific version. Useful for extending base behavior rather than replacing."
  },
  {
    "id": 272,
    "question": "What is the difference between early and late binding in virtual functions?",
    "answer": "Early binding (static binding) resolved at compile time - used for non-virtual functions. Late binding (dynamic binding) resolved at runtime via vtable - used for virtual functions. Early binding faster, can inline. Late binding enables polymorphism, supports runtime decisions based on object type."
  },
  {
    "id": 273,
    "question": "Explain the concept of virtual friends - why can't friends be virtual?",
    "answer": "Friendship isn't inherited or virtual because it's about access privileges, not polymorphic behavior. Friend declaration specifies a specific function or class gets access to private members. Virtual would imply friendship determined at runtime, but access control is compile-time concept. Use virtual functions that call friend functions if needed."
  },
  {
    "id": 274,
    "question": "What is the address of a virtual function and can you take it?",
    "answer": "Can't take address of virtual function directly and have it work polymorphically - address resolved at compile time. &Base::func gives pointer to member function (non-polymorphic). For polymorphic call, need object and vtable. Use pointers to members carefully with virtual functions - they capture non-virtual addresses."
  },
  {
    "id": 275,
    "question": "How does the compiler implement virtual function calls in switch statements?",
    "answer": "Some compilers optimize virtual calls by devirtualization - if exact type known at compile time, replace virtual call with direct call. For switch on type, may use jump table. Otherwise, standard vtable dispatch. Profile-guided optimization can identify common types and optimize accordingly."
  },
  {
    "id": 276,
    "question": "Explain the concept of virtual constructors - why aren't they possible?",
    "answer": "Constructors can't be virtual because object doesn't exist yet - vptr not set. Object construction builds from base up, setting vptrs along the way. Virtual constructor idiom (clone() factory methods) provides polymorphic object creation instead. Example: virtual Base* clone() const = 0; in base, implemented in each derived."
  },
  {
    "id": 277,
    "question": "What is the role of virtual functions in the Template Method pattern?",
    "answer": "Template Method pattern uses virtual functions for algorithm steps. Base class defines skeleton with virtual hooks, derived classes override specific steps. Example: class DataProcessor { public: void process() { read(); transform(); write(); } virtual void read() = 0; virtual void transform() {} virtual void write() = 0; }; Virtual functions customize algorithm."
  },
  {
    "id": 278,
    "question": "How does virtual function call differ from ordinary function call in assembly?",
    "answer": "Ordinary call: direct address (call _Z4funcv). Virtual call: load vptr from object (mov rax, [rbx]), load function pointer from vtable (call [rax + offset]), indirect call through register. Virtual requires extra memory access, can't be inlined, may cause branch misprediction. Modern CPUs handle reasonably well."
  },
  {
    "id": 279,
    "question": "Explain the concept of RTTI (Run-Time Type Information) and its relation to virtual functions.",
    "answer": "RTTI provides type information at runtime - typeid, dynamic_cast. Requires at least one virtual function in class. Compiler stores type_info objects for polymorphic classes. vtable often includes pointer to type_info. Enables safe downcasting, type identification. Adds overhead (space for type_info, time for dynamic_cast)."
  },
  {
    "id": 280,
    "question": "What is the difference between virtual and non-virtual interfaces (NVI) idiom?",
    "answer": "NVI makes virtual functions private/protected, provides public non-virtual wrapper. Controls access, enables pre/post conditioning. Example: class Base { public: void execute() { pre(); doExecute(); post(); } private: virtual void doExecute() = 0; }; Separates interface from customization points."
  },
  {
    "id": 281,
    "question": "How do you measure virtual function call overhead in practice?",
    "answer": "Benchmark comparing virtual calls to direct calls or function pointers. Factors: call frequency, branch prediction, inlining potential. Tools: perf, benchmark frameworks (Google Benchmark). Virtual call typically 2-5ns overhead on modern CPUs. For millions of calls per second, may matter. Profile to determine if overhead significant in your context."
  },
  {
    "id": 282,
    "question": "What are the different types of relationships between objects in OOP?",
    "answer": "Main relationships: Association (uses-a) - objects know about each other; Aggregation (has-a) - whole-part relationship, parts can exist independently; Composition (contains-a) - stronger whole-part, parts die with whole; Inheritance (is-a) - class derives from another; Dependency (uses temporarily) - method parameter or local variable. UML represents these differently."
  },
  {
    "id": 283,
    "question": "Explain the difference between association, aggregation, and composition.",
    "answer": "Association: objects connected, independent lifecycles. Aggregation: whole-part relationship, parts can exist without whole (e.g., Department has Professors). Composition: stronger ownership, parts destroyed with whole (e.g., House has Rooms). Composition implies exclusive ownership; aggregation implies shared ownership. Both are 'has-a' relationships."
  },
  {
    "id": 284,
    "question": "What is the difference between 'has-a' and 'is-a' relationships?",
    "answer": "'is-a' is inheritance - class derives from another (e.g., Dog is-a Animal). 'has-a' is composition/aggregation - class contains other objects (e.g., Car has-a Engine). Prefer composition over inheritance ('has-a' over 'is-a') when relationship isn't strict subtype. 'has-a' more flexible, less coupling."
  },
  {
    "id": 285,
    "question": "Explain the concept of multiplicity in object relationships.",
    "answer": "Multiplicity specifies how many objects participate in relationship. Common: one-to-one (1..1), one-to-many (1..*), many-to-many (*..*). Also optional (0..1), exactly N, ranges. Example: Person has 0..* Addresses (optional, many). Department has 1..* Employees (at least one). Implemented via collections, references, or foreign keys."
  },
  {
    "id": 286,
    "question": "What is a bidirectional relationship and how do you implement it?",
    "answer": "Bidirectional relationship means both objects know about each other. Example: Person has List<Address>; Address has Person owner. Implementation: both sides have references. Must maintain consistency - when setting Person on Address, also add Address to Person's list. Can cause circular references, careful with serialization, memory leaks."
  },
  {
    "id": 287,
    "question": "Explain the concept of dependency injection in object relationships.",
    "answer": "Dependency injection provides required objects from outside rather than creating internally. Types: constructor injection (dependencies passed via constructor), setter injection (via setters), interface injection. Reduces coupling, improves testability. Example: class Service { private Repository repo; public Service(Repository r) { repo = r; } } // DI through constructor."
  },
  {
    "id": 288,
    "question": "What is the difference between aggregation and composition in code?",
    "answer": "Aggregation: parts can exist independently - passed in constructor, can be shared. Composition: parts owned exclusively - created in constructor, destroyed with owner, cannot be shared. Composition implies exclusive ownership and same lifetime. Example: Car aggregates Engine (engine may be swapped), composes Chassis (chassis destroyed with car)."
  },
  {
    "id": 289,
    "question": "Explain the concept of UML class diagram relationships.",
    "answer": "UML relationships: Inheritance (solid line, hollow triangle arrow), Association (solid line, optional arrow), Aggregation (hollow diamond at whole end), Composition (filled diamond), Dependency (dashed arrow with stereotype). Multiplicity shown as numbers (1, 0..*, 1..*). Navigability arrows show direction. Essential for design documentation."
  },
  {
    "id": 290,
    "question": "What is the Law of Demeter (Principle of Least Knowledge)?",
    "answer": "Law of Demeter says object should only talk to immediate friends: itself, its members, parameters, objects it creates. Avoid method chaining like a.getB().getC().doSomething(). Reduces coupling, improves maintainability. Violation indicates exposing internal structure. Solution: provide higher-level methods that delegate."
  },
  {
    "id": 291,
    "question": "Explain the concept of friend classes/functions in C++ relationships.",
    "answer": "Friend declarations allow non-member functions or other classes access to private members. Creates coupling - use sparingly. Example: class A { friend class B; friend void helper(A&); private: int secret; }; B can access A's private members. Alternative to getters/setters for specific cases like operators, serialization."
  },
  {
    "id": 292,
    "question": "What is the difference between shallow and deep relationships in object graphs?",
    "answer": "Shallow relationships: objects directly reference each other, simple graph. Deep relationships: chains of references, complex object graphs. Deep relationships require careful copying (deep vs shallow copy), serialization, and garbage collection. Can lead to cascade operations (deleting root deletes whole graph if composition)."
  },
  {
    "id": 293,
    "question": "Explain the concept of navigation direction in object relationships.",
    "answer": "Navigation direction indicates whether objects can traverse relationship. Unidirectional: A knows B, B doesn't know A. Bidirectional: both know each other. Direction affects implementation (pointers/references one or both ways), performance, memory usage. Choose direction based on usage patterns - only navigate where needed."
  },
  {
    "id": 294,
    "question": "How do you model many-to-many relationships in OOP?",
    "answer": "Many-to-many: both sides have collections of the other. Example: Student has List<Course>, Course has List<Student>. Need to maintain consistency. Alternatively, introduce intermediate class (Enrollment) with additional attributes (grade, date). Relational mapping uses join table. Choose based on whether relationship has its own data."
  },
  {
    "id": 295,
    "question": "What is the difference between using and owning relationships?",
    "answer": "Using relationship (dependency): object temporarily uses another (method parameter, local variable). No ownership, no lifecycle management. Owning relationship (composition/aggregation): object holds reference longer-term, may manage lifecycle. Important for resource management, garbage collection, and design clarity."
  },
  {
    "id": 296,
    "question": "Explain the concept of object graphs and their management.",
    "answer": "Object graphs are networks of interconnected objects. Management challenges: circular references (memory leaks in reference-counted systems), consistency (updates propagate correctly), serialization (entire graph may need serializing), and traversal (algorithms like garbage collection). Design patterns like Visitor help traverse graphs."
  },
  {
    "id": 297,
    "question": "What is the role of interfaces in defining object relationships?",
    "answer": "Interfaces define contracts between objects without concrete coupling. Objects relate through interfaces they implement, enabling loose coupling. Example: PaymentProcessor interface with process() method. Multiple payment services implement it. Client depends on interface, not concrete classes. Enables polymorphism and dependency injection."
  },
  {
    "id": 298,
    "question": "Explain the concept of delegation in object relationships.",
    "answer": "Delegation passes responsibility to another object. Object receives request, forwards to delegate. Implements 'forwarding' rather than inheritance. Example: class Printer { private RealPrinter delegate; void print() { delegate.print(); } }; Delegation more flexible than inheritance - can change delegate at runtime. Composition with forwarding."
  },
  {
    "id": 299,
    "question": "What is the difference between composition and inheritance?",
    "answer": "Composition ('has-a') builds objects from other objects; more flexible, runtime configurable, weaker coupling. Inheritance ('is-a') extends classes; compile-time, stronger coupling, fragile base class problem. Prefer composition over inheritance (Gang of Four). Use inheritance only for true subtype relationships with LSP compliance."
  },
  {
    "id": 300,
    "question": "How do you handle circular references in object relationships?",
    "answer": "Circular references cause issues: memory leaks in reference counting (C++ shared_ptr cycles), infinite recursion in serialization/toString, difficult garbage collection. Solutions: use weak references (weak_ptr) for back references, break cycles manually, use GC that handles cycles (Java, C#). Design to minimize cycles where possible."
  },
  {
    "id": 301,
    "question": "Explain the concept of relationship cardinality in domain modeling.",
    "answer": "Cardinality defines numerical constraints: one-to-one (1:1), one-to-many (1:N), many-to-many (M:N). Also optionality: mandatory (1) vs optional (0..1). Example: Person married to Person (1:1 optional), Department has Employees (1:N mandatory at department side). Drives implementation choices - collections, nullability, foreign keys."
  },
  {
    "id": 302,
    "question": "What is the difference between aggregation and association in UML?",
    "answer": "Both show relationships, but aggregation implies whole-part with independent lifecycles (hollow diamond). Association is general connection without ownership implication (solid line). In practice, distinction subtle. Many modelers avoid aggregation, use association with notes, or composition for strong ownership. Focus on clarity over strict definitions."
  },
  {
    "id": 303,
    "question": "Explain the concept of qualified association in UML.",
    "answer": "Qualified association uses qualifier to select among many objects at the other end. Like dictionary lookup - given qualifier value, you get specific target object. Example: Directory has many Files, qualified by filename. Reduces multiplicity from many-to-one to one-to-one with qualifier. Implementation uses map keyed by qualifier."
  },
  {
    "id": 304,
    "question": "How do you model recursive relationships in OOP?",
    "answer": "Recursive relationship: object relates to same type. Example: Employee has manager (also Employee). Implemented with same-type reference. Tree structures: Node has children (List<Node>), parent reference. Graph structures: Node has List<Node> neighbors. Common in organizational hierarchies, category trees, network graphs."
  },
  {
    "id": 305,
    "question": "What is the role of the Mediator pattern in object relationships?",
    "answer": "Mediator reduces coupling between multiple objects by centralizing communication. Objects communicate through mediator rather than directly. Example: Air traffic control mediates between aircraft. Chat room mediates between users. Prevents many-to-many relationships becoming unmanageable, simplifies protocols."
  },
  {
    "id": 306,
    "question": "Explain the concept of relationship inversion (Dependency Inversion).",
    "answer": "Dependency Inversion Principle: depend on abstractions, not concretions. High-level modules shouldn't depend on low-level; both depend on abstractions. Flips traditional dependency direction. Example: Business logic depends on Repository interface, not concrete SqlRepository. Concrete depends on same interface. Enables pluggable architecture."
  },
  {
    "id": 307,
    "question": "What is the difference between static and dynamic relationships?",
    "answer": "Static relationships defined at compile time: inheritance, template instantiation. Dynamic relationships established at runtime: object references, dependency injection. Static relationships rigid but type-safe; dynamic relationships flexible but runtime-checked. Modern design favors dynamic for extensibility, static for performance."
  },
  {
    "id": 308,
    "question": "How do ORMs (Object-Relational Mappers) handle object relationships?",
    "answer": "ORMs map OOP relationships to database: one-to-one (foreign key), one-to-many (collection, foreign key), many-to-many (join table). Handle lazy loading (load on access), eager loading (load with parent), cascading (save/delete propagate). Example: JPA @OneToMany, @ManyToOne annotations. Challenges: N+1 queries, object graph consistency."
  },
  {
    "id": 309,
    "question": "Explain the concept of relationship multiplicity and its implementation.",
    "answer": "Multiplicity implementation: 1:1 - direct reference (possibly nullable). 1:N - collection in 'one' side, reference in 'many' side. M:N - collections both sides, or intermediate class. Optional: nullable references. Mandatory: ensure non-null construction, validation. Implement with language collections (List, Set) and proper encapsulation."
  },
  {
    "id": 310,
    "question": "What is the role of the Observer pattern in object relationships?",
    "answer": "Observer defines one-to-many dependency: when subject changes, observers notified. Objects relate through subscription. Example: UI components observe data model. Stock price changes notify multiple displays. Decouples subject from observers - subjects know only Observer interface. Maintains relationships dynamically as observers subscribe/unsubscribe."
  },
  {
    "id": 311,
    "question": "How do you ensure relationship invariants are maintained?",
    "answer": "Encapsulate relationships - control modifications through methods that maintain consistency. Example: addStudentToCourse() updates both sides. Use validation in setters. Consider using domain events for complex invariants. In bidirectional relationships, designate one side as owner responsible for consistency. Test relationship invariants thoroughly."
  }
]